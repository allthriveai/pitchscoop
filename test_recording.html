<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PitchScoop Recording Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .recording-section {
            text-align: center;
            margin: 30px 0;
        }
        .record-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }
        .record-btn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }
        .record-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        .recording {
            background: #e74c3c;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .stop-btn {
            background: #2c3e50;
        }
        .stop-btn:hover {
            background: #34495e;
        }
        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
            min-height: 20px;
        }
        .status.info {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .form-group {
            margin: 20px 0;
            text-align: left;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }
        input[type="text"]:focus {
            border-color: #3498db;
            outline: none;
        }
        .results {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .audio-player {
            width: 100%;
            margin: 15px 0;
        }
        .playback-url {
            word-break: break-all;
            background: #e9ecef;
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        .timer {
            font-size: 24px;
            color: #e74c3c;
            margin: 10px 0;
            font-weight: bold;
        }
        .config-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #17a2b8;
        }
        .config-section h3 {
            margin-top: 0;
            color: #17a2b8;
        }
        .checkbox-group {
            margin: 10px 0;
        }
        input[type="checkbox"] {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ PitchScoop Recording Test</h1>
        
        <div class="config-section">
            <h3>Recording Configuration</h3>
            <div class="form-group">
                <label for="teamName">Team Name:</label>
                <input type="text" id="teamName" value="Test Team" placeholder="Enter team name">
            </div>
            <div class="form-group">
                <label for="pitchTitle">Pitch Title:</label>
                <input type="text" id="pitchTitle" value="Browser Recording Test" placeholder="Enter pitch title">
            </div>
            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="autoUpload" checked> Auto-upload after recording
                </label>
            </div>
            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="showAdvanced"> Show advanced options
                </label>
            </div>
        </div>

        <div class="recording-section">
            <div class="timer" id="timer">00:00</div>
            <button id="startBtn" class="record-btn">üî¥ Start Recording</button>
            <button id="stopBtn" class="record-btn stop-btn" disabled>‚èπÔ∏è Stop Recording</button>
            <button id="uploadBtn" class="record-btn stop-btn" disabled>üì§ Upload to PitchScoop</button>
        </div>

        <div id="status" class="status info">
            Ready to record. Click "Start Recording" to begin.
        </div>

        <div id="results" class="results" style="display:none;">
            <h3>üìä Recording Results</h3>
            <div id="sessionInfo"></div>
            <div id="audioPlayer"></div>
            <div id="playbackUrl"></div>
        </div>
    </div>

    <script>
        let mediaRecorder;
        let recordedChunks = [];
        let stream;
        let startTime;
        let timerInterval;
        let recordedBlob;
        
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const status = document.getElementById('status');
        const results = document.getElementById('results');
        const timer = document.getElementById('timer');
        
        // API endpoint - using the simple test server
        const API_BASE_URL = 'http://localhost:8000';
        
        function updateStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
        }
        
        function updateTimer() {
            if (!startTime) return;
            const elapsed = Date.now() - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            timer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        async function startRecording() {
            try {
                // Request microphone access
                updateStatus('Requesting microphone access...', 'warning');
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                recordedChunks = [];
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    recordedBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    clearInterval(timerInterval);
                    
                    // Create local audio player
                    const audioURL = URL.createObjectURL(recordedBlob);
                    const audioPlayer = document.getElementById('audioPlayer');
                    audioPlayer.innerHTML = `
                        <h4>üéµ Recorded Audio (${Math.round(recordedBlob.size / 1024)}KB)</h4>
                        <audio controls class="audio-player">
                            <source src="${audioURL}" type="audio/webm">
                            Your browser does not support the audio element.
                        </audio>
                    `;
                    
                    updateStatus('Recording completed! You can play it back or upload to PitchScoop.', 'info');
                    uploadBtn.disabled = false;
                    
                    // Auto-upload if enabled
                    if (document.getElementById('autoUpload').checked) {
                        await uploadRecording();
                    }
                };
                
                // Start recording
                mediaRecorder.start(100); // Record in 100ms chunks
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 100);
                
                startBtn.disabled = true;
                startBtn.className = 'record-btn recording';
                stopBtn.disabled = false;
                
                updateStatus('üî¥ Recording... Speak into your microphone!', 'info');
                
            } catch (error) {
                updateStatus(`Failed to start recording: ${error.message}`, 'error');
                console.error('Recording error:', error);
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                stream.getTracks().forEach(track => track.stop());
                
                startBtn.disabled = false;
                startBtn.className = 'record-btn';
                stopBtn.disabled = true;
                
                results.style.display = 'block';
            }
        }
        
        async function uploadRecording() {
            if (!recordedBlob) {
                updateStatus('No recording to upload!', 'error');
                return;
            }
            
            try {
                updateStatus('Uploading to PitchScoop...', 'warning');
                uploadBtn.disabled = true;
                
                const teamName = document.getElementById('teamName').value || 'Test Team';
                const pitchTitle = document.getElementById('pitchTitle').value || 'Browser Recording Test';
                
                // Step 1: Create an event
                updateStatus('Creating event...', 'warning');
                const eventResponse = await fetch(`${API_BASE_URL}/mcp/execute`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tool: 'events.create_event',
                        arguments: {
                            event_type: 'individual_practice',
                            event_name: 'Browser Recording Test Event',
                            description: 'Test event created from browser recording',
                            max_participants: 1,
                            duration_minutes: 10
                        }
                    })
                });
                
                const eventData = await eventResponse.json();
                if (eventData.error) {
                    throw new Error(`Event creation failed: ${eventData.error}`);
                }
                
                const eventId = eventData.event_id;
                updateStatus(`Event created: ${eventId}`, 'info');
                
                // Step 2: Start recording session
                updateStatus('Starting recording session...', 'warning');
                const sessionResponse = await fetch(`${API_BASE_URL}/mcp/execute`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tool: 'pitches.start_recording',
                        arguments: {
                            event_id: eventId,
                            team_name: teamName,
                            pitch_title: pitchTitle
                        }
                    })
                });
                
                const sessionData = await sessionResponse.json();
                if (sessionData.error) {
                    throw new Error(`Session creation failed: ${sessionData.error}`);
                }
                
                const sessionId = sessionData.session_id;
                updateStatus(`Recording session created: ${sessionId}`, 'info');
                
                // Step 3: Convert audio to WAV and base64 encode
                updateStatus('Converting audio to WAV format...', 'warning');
                
                // Create an audio context to convert to WAV
                const audioContext = new AudioContext();
                const arrayBuffer = await recordedBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // Convert to WAV
                const wavBlob = audioBufferToWav(audioBuffer);
                const reader = new FileReader();
                
                reader.onload = async () => {
                    const base64Audio = reader.result.split(',')[1]; // Remove data:audio/wav;base64, prefix
                    
                    // Step 4: Stop recording with audio data
                    updateStatus('Uploading audio to MinIO...', 'warning');
                    const stopResponse = await fetch(`${API_BASE_URL}/mcp/execute`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            tool: 'pitches.stop_recording',
                            arguments: {
                                session_id: sessionId,
                                audio_data_base64: base64Audio
                            }
                        })
                    });
                    
                    const stopData = await stopResponse.json();
                    if (stopData.error) {
                        throw new Error(`Upload failed: ${stopData.error}`);
                    }
                    
                    // Step 5: Get playback URL
                    updateStatus('Generating playback URL...', 'warning');
                    const playbackResponse = await fetch(`${API_BASE_URL}/mcp/execute`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            tool: 'pitches.get_playback_url',
                            arguments: {
                                session_id: sessionId,
                                expires_hours: 24
                            }
                        })
                    });
                    
                    const playbackData = await playbackResponse.json();
                    
                    // Display results
                    const sessionInfo = document.getElementById('sessionInfo');
                    
                    // Check for transcript
                    let transcriptHtml = '';
                    if (stopData.transcript) {
                        const transcript = stopData.transcript;
                        const totalText = transcript.total_text || '';
                        const segmentCount = transcript.segments_count || 0;
                        
                        if (totalText.trim()) {
                            transcriptHtml = `
                                <h4>üìù Transcript</h4>
                                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
                                    <strong>"${totalText}"</strong>
                                </div>
                                <p><small>Segments: ${segmentCount}</small></p>
                            `;
                        } else if (segmentCount > 0) {
                            transcriptHtml = `
                                <h4>üìù Transcript</h4>
                                <p><em>Processing completed but no text detected (${segmentCount} segments processed)</em></p>
                            `;
                        } else {
                            transcriptHtml = `
                                <h4>üìù Transcript</h4>
                                <p><em>No transcript segments detected - this may happen with synthetic audio or background noise</em></p>
                            `;
                        }
                    }
                    
                    sessionInfo.innerHTML = `
                        <h4>‚úÖ Upload Successful!</h4>
                        <p><strong>Session ID:</strong> ${sessionId}</p>
                        <p><strong>Event ID:</strong> ${eventId}</p>
                        <p><strong>Team:</strong> ${teamName}</p>
                        <p><strong>Title:</strong> ${pitchTitle}</p>
                        <p><strong>Status:</strong> ${stopData.status}</p>
                        <p><strong>File Size:</strong> ${Math.round(wavBlob.size / 1024)}KB (WAV format)</p>
                        ${transcriptHtml}
                    `;
                    
                    // Display playback URL - check both stopData and playbackData
                    const playbackUrl = document.getElementById('playbackUrl');
                    let audioUrl = null;
                    
                    // First try to get URL from stopData (more reliable)
                    if (stopData.audio && stopData.audio.playback_url) {
                        audioUrl = stopData.audio.playback_url;
                    } else if (playbackData && playbackData.playback_url) {
                        audioUrl = playbackData.playback_url;
                    }
                    
                    if (audioUrl) {
                        playbackUrl.innerHTML = `
                            <h4>üîó MinIO Playback URL:</h4>
                            <div class="playback-url">${audioUrl}</div>
                            <p><small>This URL expires in 24 hours</small></p>
                            <audio controls class="audio-player">
                                <source src="${audioUrl}" type="audio/wav">
                                Your browser does not support the audio element.
                            </audio>
                        `;
                    } else {
                        playbackUrl.innerHTML = '<p>‚ö†Ô∏è No playback URL available</p>';
                    }
                    
                    updateStatus('üéâ Recording successfully uploaded to MinIO!', 'info');
                };
                
                reader.readAsDataURL(wavBlob);
                
            } catch (error) {
                updateStatus(`Upload failed: ${error.message}`, 'error');
                console.error('Upload error:', error);
                uploadBtn.disabled = false;
            }
        }
        
        // Convert AudioBuffer to WAV Blob
        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const sampleRate = buffer.sampleRate;
            const arrayBuffer = new ArrayBuffer(44 + length * 2);
            const view = new DataView(arrayBuffer);
            const channelData = buffer.getChannelData(0);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * 2, true);
            
            // Convert float samples to 16-bit PCM
            let offset = 44;
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, channelData[i]));
                view.setInt16(offset, sample * 0x7FFF, true);
                offset += 2;
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }
        
        // Event listeners
        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        uploadBtn.addEventListener('click', uploadRecording);
        
        // Check if browser supports recording
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            updateStatus('Your browser does not support audio recording!', 'error');
            startBtn.disabled = true;
        }
    </script>
</body>
</html>